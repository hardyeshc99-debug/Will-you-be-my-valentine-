<meta name='viewport' content='width=device-width, initial-scale=1'/><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>For Denisa | Love Hardyesh</title>
    
    <!-- Google Fonts for elegant typography -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Montserrat:wght@300;500&display=swap" rel="stylesheet">
    
    <!-- Link to your CSS file -->
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <!-- The 3D Canvas will be generated here by JS -->
    
    <!-- The Text Overlay -->
    <div class="container">
        <div class="content">
            <h2 class="couple-name">Denisa & Hardyesh</h2>
            <h1 class="main-title">My Living Heart</h1>
            <p class="message">
                Every beat of this heart belongs to you.<br>
                I am looking forward to every moment<br>
                we will spend together.
            </p>
            <div class="footer">Valentine's Day 2026</div>
        </div>
    </div>

    <!-- Link to your JS file (Note the type="module") -->
    <script type="module" src="script.js"></script>
</body>
</html><style>/* Reset and Base Styles */
body, html {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden; /* Prevents scrolling */
    background-color: #050011; /* Deep space dark purple */
    font-family: 'Montserrat', sans-serif;
}

canvas {
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1; /* Behind the text */
}

/* The Container for Text */
.container {
    position: absolute;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10; /* On top of the 3D canvas */
    pointer-events: none; /* Allows mouse clicks to go through to the 3D animation */
}

.content {
    text-align: center;
    color: white;
    background: rgba(255, 255, 255, 0.05); /* Subtle glass effect */
    backdrop-filter: blur(2px);
    padding: 2rem 3rem;
    border-radius: 20px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
    animation: float 6s ease-in-out infinite;
}

/* Typography Styling */
.couple-name {
    font-size: 1.2rem;
    letter-spacing: 4px;
    text-transform: uppercase;
    color: #ff8fa3;
    margin-bottom: 10px;
    opacity: 0.9;
}

.main-title {
    font-family: 'Dancing Script', cursive;
    font-size: 4.5rem;
    margin: 0;
    background: linear-gradient(45deg, #ff0055, #ff5e98);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    text-shadow: 0 0 20px rgba(255, 0, 85, 0.3);
}

.message {
    font-size: 1.1rem;
    line-height: 1.8;
    margin-top: 20px;
    font-weight: 300;
    text-shadow: 0 2px 4px rgba(0,0,0,0.8);
}

.footer {
    margin-top: 30px;
    font-size: 0.8rem;
    opacity: 0.6;
    letter-spacing: 2px;
}

/* Floating animation for the text box */
@keyframes float {
    0% { transform: translateY(0px); }
    50% { transform: translateY(-10px); }
    100% { transform: translateY(0px); }
}

/* Mobile Responsiveness */
@media (max-width: 768px) {
    .main-title { font-size: 3rem; }
    .content { width: 80%; padding: 1.5rem; }
    .message { font-size: 1rem; }
}</style><script>import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

// --- 1. SETUP THE SCENE ---
const scene = new THREE.Scene();
// Add fog to blend particles into the distance
scene.fog = new THREE.FogExp2(0x050011, 0.002);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 25; // How far back the camera is

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

// --- 2. CREATE THE HEART ---
const heartGeometry = new THREE.BufferGeometry();
const particlesCount = 12000; // Number of dots in the heart

const posArray = new Float32Array(particlesCount * 3);
const colorsArray = new Float32Array(particlesCount * 3);

// We use a specific math formula to calculate the heart shape
for(let i = 0; i < particlesCount; i++) {
    const i3 = i * 3;

    // x = 16sin^3(t)
    // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
    
    const t = Math.random() * Math.PI * 2;
    // This 'r' variable adds volume/thickness to the heart so it's 3D, not flat
    const r = Math.random() * 0.4; 

    let x = 16 * Math.pow(Math.sin(t), 3);
    let y = 13 * Math.cos(t) - 5 * Math.cos(2t) - 2 * Math.cos(3t) - Math.cos(4t);
    let z = (Math.random() - 0.5) * 5; // Depth

    // Randomize slightly to fill the volume
    const scatter = 1 - Math.pow(Math.random(), 5); // Concentrates points in the center
    const scale = 0.5; // Overall size of the heart

    posArray[i3] = x * scale * scatter;
    posArray[i3+1] = y * scale * scatter;
    posArray[i3+2] = z * scale * scatter;

    // Colors: Mix of Red (1,0,0) and Hot Pink (1, 0, 0.5)
    colorsArray[i3] = 1; // Red channel
    colorsArray[i3+1] = 0; // Green channel
    colorsArray[i3+2] = Math.random() * 0.5; // Blue channel (creates pinks)
}

heartGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
heartGeometry.setAttribute('color', new THREE.BufferAttribute(colorsArray, 3));

// Material for the particles
const heartMaterial = new THREE.PointsMaterial({
    size: 0.12,
    vertexColors: true, // Use the colors we defined above
    blending: THREE.AdditiveBlending, // Makes overlapping particles glow
    transparent: true,
    opacity: 0.8
});

const heartMesh = new THREE.Points(heartGeometry, heartMaterial);
scene.add(heartMesh);

// --- 3. CREATE THE STARS BACKGROUND ---
const starsGeometry = new THREE.BufferGeometry();
const starsCount = 2000;
const starsPos = new Float32Array(starsCount * 3);

for(let i = 0; i < starsCount * 3; i++) {
    starsPos[i] = (Math.random() - 0.5) * 80; // Spread them wide
}

starsGeometry.setAttribute('position', new THREE.BufferAttribute(starsPos, 3));
const starsMaterial = new THREE.PointsMaterial({
    size: 0.05,
    color: 0xffffff,
    transparent: true,
    opacity: 0.6
});
const starsMesh = new THREE.Points(starsGeometry, starsMaterial);
scene.add(starsMesh);

// --- 4. INTERACTION ---
let mouseX = 0;
let mouseY = 0;
let targetX = 0;
let targetY = 0;

// Listen for mouse movement
document.addEventListener('mousemove', (event) => {
    mouseX = event.clientX - window.innerWidth / 2;
    mouseY = event.clientY - window.innerHeight / 2;
});

// Listen for touch movement (for mobile)
document.addEventListener('touchmove', (event) => {
    if (event.touches.length > 0) {
        mouseX = event.touches[0].clientX - window.innerWidth / 2;
        mouseY = event.touches[0].clientY - window.innerHeight / 2;
    }
});

// --- 5. ANIMATION LOOP ---
const clock = new THREE.Clock();

function tick() {
    const elapsedTime = clock.getElapsedTime();

    // 1. Heart Beat Animation (Pulsing)
    // Using Math.sin to make it grow and shrink rhythmically
    const beat = 1 + Math.sin(elapsedTime * 3) * 0.05 + Math.sin(elapsedTime * 10) * 0.02;
    heartMesh.scale.set(beat, beat, beat);

    // 2. Rotation
    // Continuous slow rotation
    heartMesh.rotation.y += 0.002;
    
    // Mouse interaction rotation (Smooth easing)
    targetX = mouseX * 0.001;
    targetY = mouseY * 0.001;
    
    heartMesh.rotation.y += 0.5 * (targetX - heartMesh.rotation.y);
    heartMesh.rotation.x += 0.05 * (targetY - heartMesh.rotation.x);

    // 3. Background movement
    starsMesh.rotation.y -= 0.0002;

    // Render
    renderer.render(scene, camera);

    // Call tick again on the next frame
    window.requestAnimationFrame(tick);
}

// Handle Window Resize (so it works on phones and desktops)
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// Start the animation
tick();</script>